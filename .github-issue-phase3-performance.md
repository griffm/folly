# Phase 3.2-3.3: Performance Optimizations for Font System

## Issue Type
Enhancement / Performance

## Priority
Medium (defer to Phase 3.4 or later)

## Summary
The current TrueType font embedding and system font discovery implementation has several performance issues that need optimization before production deployment in high-throughput scenarios.

## Background
Phase 3.2 and 3.3 implemented TrueType font embedding and system font discovery. While functionally complete (after critical bug fixes), the implementation has performance characteristics that make it unsuitable for high-volume production use.

## Performance Issues

### 1. Full Font File Loading into Memory
**Location:** `PdfWriter.cs:855`
```csharp
var fontData = File.ReadAllBytes(fontPath);
```

**Problem:**
- Loads entire font file into memory for embedding
- Typical fonts: 168 KB - 15 MB (for CJK fonts)
- With 10 embedded fonts: 1.6 MB - 150 MB in memory
- Memory pressure in high-concurrency scenarios

**Impact:** High memory usage, potential OOM in constrained environments

**Proposed Fix:**
- Use stream-based processing where possible
- Consider memory-mapped files for large fonts
- Implement font data caching with LRU eviction

**Estimated Effort:** 1 week

---

### 2. System Font Scanning Performance
**Location:** `FontResolver.cs:89-131`

**Problem:**
- Scans ALL font directories recursively on first call
- Parses EVERY font file to extract family name
- Windows: ~1000 fonts = 5-10 seconds first call
- Linux: ~500 fonts = 2-5 seconds
- Blocks rendering thread during scan

**Impact:** Unacceptable latency on first PDF render with `EnableFontFallback=true`

**Proposed Fixes:**
1. **Lazy scanning** - Only scan on-demand when font not found in cache
2. **Async scanning** - Non-blocking background scan
   ```csharp
   public async Task<string?> ResolveFontFamilyAsync(string fontFamilyStack, CancellationToken ct = default)
   ```
3. **Persistent cache** - Save discovered fonts to disk
   ```csharp
   // ~/.folly/font-cache.json
   {
     "Arial": "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
     "Times New Roman": "/usr/share/fonts/truetype/liberation/LiberationSerif-Regular.ttf"
   }
   ```
4. **Scan timeout** - Limit scan duration
   ```csharp
   private void ScanSystemFonts(TimeSpan timeout = default)
   {
       using var cts = new CancellationTokenSource(timeout ?? TimeSpan.FromSeconds(10));
       // ...
   }
   ```

**Estimated Effort:** 1-2 weeks

---

### 3. No Thread Safety
**Location:** `FontResolver.cs:61-65`

**Problem:**
```csharp
if (!_systemFontsScanned)  // ← Check
{
    ScanSystemFonts();     // ← Modify (not thread-safe)
    _systemFontsScanned = true;
}
```

- Race condition in check-then-set pattern
- Dictionary modifications not synchronized
- Multiple threads can scan simultaneously
- Potential corruption or crashes in parallel PDF generation

**Impact:** Thread-safety violations in multi-threaded servers

**Proposed Fix:**
```csharp
private readonly object _scanLock = new();
private volatile bool _systemFontsScanned;

if (!_systemFontsScanned)
{
    lock (_scanLock)
    {
        if (!_systemFontsScanned)
        {
            ScanSystemFonts();
            _systemFontsScanned = true;
        }
    }
}
```

Or use `ConcurrentDictionary` and `Lazy<T>` for lock-free scanning.

**Estimated Effort:** 2-3 days

---

### 4. Unbounded Cache Growth
**Location:** `FontResolver.cs:16, 114-117`

**Problem:**
```csharp
private readonly Dictionary<string, string> _systemFontCache;

// No size limits
if (!_systemFontCache.ContainsKey(familyName))
{
    _systemFontCache[familyName] = fontFile;  // Grows indefinitely
}
```

- System with 2000 fonts = 2000+ cache entries
- No LRU eviction
- Memory scales linearly with # of fonts
- No way to configure max cache size

**Impact:** Unbounded memory growth on systems with many fonts

**Proposed Fixes:**
1. Implement LRU cache with size limit
2. Add configuration option for max cache size
3. Consider using `MemoryCache` with expiration

**Estimated Effort:** 3-4 days

---

### 5. Platform-Specific Optimizations

**Linux:** Use `fontconfig` instead of filesystem scanning
```bash
# Much faster than parsing all fonts
fc-list : family file | grep "Arial"
```

**macOS:** Use CoreText APIs
```csharp
// Native font enumeration (if using P/Invoke)
CTFontManagerCopyAvailableFontFamilyNames()
```

**Windows:** Query registry for installed fonts
```csharp
// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts
var fontsKey = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts");
```

**Estimated Effort:** 1-2 weeks (platform-specific testing required)

---

## Success Metrics

**Performance Targets:**
- [ ] System font scanning: < 500ms (currently 5-10s)
- [ ] Font resolution: < 10ms per call
- [ ] Memory usage: < 5 MB for font cache (currently unbounded)
- [ ] Thread-safe: 100 concurrent font resolutions without errors
- [ ] Persistent cache: < 100ms cold start with cached fonts

**Benchmark Suite:**
- [ ] Benchmark font scanning on Windows (1000+ fonts)
- [ ] Benchmark font scanning on macOS (500+ fonts)
- [ ] Benchmark font scanning on Linux (500+ fonts)
- [ ] Benchmark parallel font resolution (100 threads)
- [ ] Benchmark memory usage with large font sets
- [ ] Benchmark persistent cache performance

---

## Implementation Plan

### Phase 1: Critical Fixes (Week 1)
- [ ] Add thread safety (double-checked locking)
- [ ] Add scan timeout (10 second default)
- [ ] Add cache size limits (500 fonts max)

### Phase 2: Performance Improvements (Week 2-3)
- [ ] Implement lazy scanning
- [ ] Add async font resolution APIs
- [ ] Implement persistent cache

### Phase 3: Platform Optimizations (Week 4)
- [ ] Linux: fontconfig integration
- [ ] Windows: registry querying
- [ ] macOS: CoreText integration (if feasible)

### Phase 4: Benchmarking & Tuning (Week 5)
- [ ] Create comprehensive benchmark suite
- [ ] Profile and optimize hot paths
- [ ] Document performance characteristics

---

## Dependencies
- Requires Phase 3.2 critical bug fixes (character encoding, glyph serialization)
- No external dependencies (stay zero-dependency)

## Related Issues
- #XX - Phase 3.2: Missing glyph outline data
- #XX - Phase 3.2: Character code collisions (modulo 256)
- #XX - Phase 3.2: Incorrect loca table offsets

## Testing Requirements
- [ ] Unit tests for thread safety
- [ ] Performance regression tests
- [ ] Cross-platform testing (Windows, macOS, Linux)
- [ ] Load testing with 1000+ concurrent requests

---

## Notes
This work is deferred to Phase 3.4 or later because:
1. Critical correctness bugs must be fixed first (Priorities 1-3)
2. Current performance is acceptable for low-volume use
3. Opt-in feature (`EnableFontFallback=false` by default)
4. Requires significant platform-specific work and testing

**Estimated Total Effort:** 3-5 weeks
**Recommended Timeline:** Q1 2026 (after Phase 3.2 bug fixes)
